 /*=========================================================================

  Program:   Visualization Toolkit
  Module:    vtkThreadLocal.h

  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen
  All rights reserved.
  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.

     This software is distributed WITHOUT ANY WARRANTY; without even
     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
     PURPOSE.  See the above copyright notice for more information.

=========================================================================*/
// .NAME vtkThreadLocal - A Kaapi based thread local storage implementation.
// .SECTION Description
// A thread local object is one that maintains a copy of an object of the
// template type for each thread that processes data. vtkThreadLocal
// creates storage for all threads but the actual objects are created
// the first time Local() is called. Note that vtkThreadLocal is actually
// not very thread safe. It can be safely used in a multi-threaded
// environment becauase Local() returns storage specific to a particular
// thread, which by default will be accessed sequentially. It is also
// thread-safe to iterator over vtkThreadLocal as long as each thread
// creates its own iterators and do not change any of the thread local
// objects.
//
// A common design pattern ins using a thread local storage object is to
// write/accumulate data to local object when executing in parallel and
// the having a sequential code block that iterates over the whole storage
// using the iterators to do the final accumulation.

#ifndef __vtkThreadLocal_h
#define __vtkThreadLocal_h

#include <kaapic.h>

template <typename T>
class vtkThreadLocal
{
  typedef std::vector<T> TLS;
  typedef typename TLS::iterator TLSIter;
public:
  // Description:
  // Default constructor. Creates a default examplar.
  vtkThreadLocal()
    {
      this->Initialize();
    }

  // Description:
  // Constructor that allows the specification of an exemplar object
  // which is used when constructing objects when Local() is first called.
  // Note that a copy of the exemplar is created using its copy constructor.
  vtkThreadLocal(const T& exemplar)
    {
      this->Exemplar = exemplar;
      this->Initialize();
    }

++  // Description:
  // Returns an object of type T that is local to the current thread.
  // This needs to be called mainly within a threaded execution path.
  // It will create a new object (local to the tread so each thread
  // get their own when calling Local) which is a copy of exemplar as passed
  // to the constructor (or a default object if no exemplar was provided)
  // the first time it is called. After the first time, it will return
  // the same object.
  T& Local()
    {
      int tid = this->GetThreadID();
      if (!this->Initialized[tid])
        {
        this->Internal[tid] = this->Exemplar;
        this->Initialized[tid] = true;
        }
      return this->Internal[tid];
    }

  // Description:
  // Subset of the standard iterator API.
  // The most common design patter is to use iterators in a sequential
  // code block and to use only the thread local objects in parallel
  // code blocks.
  class iterator
  {
  public:
    iterator& operator++()
      {
        this->InitIter++;
        this->Iter++;

        // Make sure to skip uninitialized
        // entries.
        while(this->InitIter != this->EndIter)
          {
          if (*this->InitIter)
            {
            break;
            }
          this->InitIter++;
          this->Iter++;
          }
        return *this;
      }

    bool operator!=(const iterator& other)
      {
        return this->Iter != other.Iter;
      }

    T& operator*()
      {
        return *this->Iter;
      }

  private:
    friend class vtkThreadLocal<T>;
    std::vector<bool>::iterator InitIter;
    std::vector<bool>::iterator EndIter;
    TLSIter Iter;
  };

  iterator begin()
    {
      TLSIter iter = this->Internal.begin();
      std::vector<bool>::iterator iter2 =
        this->Initialized.begin();
      std::vector<bool>::iterator end =
        this->Initialized.end();
      // fast forward to first initialized
      // value
      while(iter2 != end)
        {
        if (*iter2)
          {
          break;
          }
        iter2++;
        iter++;
        }
      iterator retVal;
      retVal.InitIter = iter2;
      retVal.EndIter = end;
      retVal.Iter = iter;
      return retVal;
    };

  iterator end()
    {
      iterator retVal;
      retVal.InitIter = this->Initialized.end();
      retVal.EndIter = this->Initialized.end();
      retVal.Iter = this->Internal.end();
      return retVal;
    }

private:
  TLS Internal;
  std::vector<bool> Initialized;
  T Exemplar;

  void Initialize()
    {
      this->Internal.resize(this->GetNumberOfThreads());
      this->Initialized.resize(this->GetNumberOfThreads());
      std::fill(this->Initialized.begin(),
                this->Initialized.end(),
                false);
    }

  inline int GetNumberOfThreads()
    {
      return kaapi_getconcurrency();
    }

  inline int GetThreadID()
    {
      return kaapi_get_self_kid();
    }
};

#endif
// VTK-HeaderTest-Exclude: vtkThreadLocal.h
